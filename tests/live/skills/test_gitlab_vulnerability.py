"""
Live integration tests for gitlab-vulnerability skill.

Tests security vulnerability operations via API.
Requires GitLab Ultimate license for full functionality.
"""

import pytest

from tests.live.skills.base import APISkillTest
try:
    # When running under pytest, conftest is loaded directly
    from conftest import GitLabAPI, GitLabAPIError
except ImportError:
    # When running directly, use the full path
    from tests.live.conftest import GitLabAPI, GitLabAPIError


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityList(APISkillTest):
    """Tests for listing vulnerabilities."""

    @pytest.mark.readonly
    def test_list_project_vulnerabilities(self, gitlab_api: GitLabAPI, gitlab_project_id: int):
        """Test listing project vulnerabilities."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities",
            expected_status=404  # May require Ultimate
        )
        if vulnerabilities:
            self.assert_is_list(vulnerabilities)

    @pytest.mark.readonly
    def test_list_vulnerabilities_with_filters(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test listing vulnerabilities with severity filter."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities?severity=critical",
            expected_status=404
        )
        if vulnerabilities:
            self.assert_is_list(vulnerabilities)

    @pytest.mark.readonly
    def test_list_vulnerabilities_by_state(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test listing vulnerabilities by state."""
        for state in ["detected", "confirmed", "dismissed", "resolved"]:
            vulnerabilities = self.api_get(
                gitlab_api,
                f"/projects/{gitlab_project_id}/vulnerabilities?state={state}",
                expected_status=404
            )
            if vulnerabilities:
                self.assert_is_list(vulnerabilities)


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityGet(APISkillTest):
    """Tests for getting vulnerability details."""

    @pytest.mark.readonly
    def test_get_vulnerability(self, gitlab_api: GitLabAPI, gitlab_project_id: int):
        """Test getting a specific vulnerability."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities",
            expected_status=404
        )
        if vulnerabilities:
            vuln_id = vulnerabilities[0]["id"]
            vuln = self.api_get(gitlab_api, f"/vulnerabilities/{vuln_id}")
            self.assert_is_dict(vuln)
            self.assert_has_field(vuln, "severity")
            self.assert_has_field(vuln, "state")


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityUpdate(APISkillTest):
    """Tests for updating vulnerabilities."""

    @pytest.mark.destructive
    def test_dismiss_vulnerability(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test dismissing a vulnerability."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities?state=detected",
            expected_status=404
        )
        if not vulnerabilities:
            pytest.skip("No detected vulnerabilities available")

        vuln_id = vulnerabilities[0]["id"]

        try:
            dismissed = self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/dismiss",
                {"comment": "Test dismissal"}
            )
            self.assert_is_dict(dismissed)
            self.assert_field_equals(dismissed, "state", "dismissed")

            # Revert to detected state
            self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/revert",
                {}
            )
        except GitLabAPIError:
            pytest.skip("Vulnerability state change failed")

    @pytest.mark.destructive
    def test_confirm_vulnerability(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test confirming a vulnerability."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities?state=detected",
            expected_status=404
        )
        if not vulnerabilities:
            pytest.skip("No detected vulnerabilities available")

        vuln_id = vulnerabilities[0]["id"]

        try:
            confirmed = self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/confirm",
                {}
            )
            self.assert_is_dict(confirmed)
            self.assert_field_equals(confirmed, "state", "confirmed")

            # Revert
            self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/revert",
                {}
            )
        except GitLabAPIError:
            pytest.skip("Vulnerability state change failed")

    @pytest.mark.destructive
    def test_resolve_vulnerability(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test resolving a vulnerability."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities?state=detected",
            expected_status=404
        )
        if not vulnerabilities:
            pytest.skip("No detected vulnerabilities available")

        vuln_id = vulnerabilities[0]["id"]

        try:
            resolved = self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/resolve",
                {}
            )
            self.assert_is_dict(resolved)
            self.assert_field_equals(resolved, "state", "resolved")

            # Revert
            self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/revert",
                {}
            )
        except GitLabAPIError:
            pytest.skip("Vulnerability state change failed")


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityFindings(APISkillTest):
    """Tests for vulnerability findings."""

    @pytest.mark.readonly
    def test_list_vulnerability_findings(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test listing vulnerability findings."""
        findings = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerability_findings",
            expected_status=404
        )
        if findings:
            self.assert_is_list(findings)


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityExports(APISkillTest):
    """Tests for vulnerability exports."""

    @pytest.mark.readonly
    def test_list_vulnerability_exports(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test listing vulnerability exports."""
        exports = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerability_exports",
            expected_status=404
        )
        if exports:
            self.assert_is_list(exports)

    @pytest.mark.destructive
    def test_create_vulnerability_export(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test creating a vulnerability export."""
        try:
            export = self.api_post(
                gitlab_api,
                f"/projects/{gitlab_project_id}/vulnerability_exports",
                {}
            )
            self.assert_is_dict(export)
            self.assert_has_field(export, "id")
        except GitLabAPIError:
            pytest.skip("Vulnerability export creation requires Ultimate")


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityGroup(APISkillTest):
    """Tests for group-level vulnerability aggregation."""

    @pytest.mark.readonly
    def test_list_group_vulnerabilities(
        self,
        gitlab_api: GitLabAPI,
        gitlab_group_id: int,
    ):
        """Test listing vulnerabilities for a group."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/groups/{gitlab_group_id}/vulnerabilities",
            expected_status=404
        )
        if vulnerabilities:
            self.assert_is_list(vulnerabilities)

    @pytest.mark.readonly
    def test_group_vulnerability_statistics(
        self,
        gitlab_api: GitLabAPI,
        gitlab_group_id: int,
    ):
        """Test getting group vulnerability statistics."""
        stats = self.api_get(
            gitlab_api,
            f"/groups/{gitlab_group_id}/vulnerability_statistics",
            expected_status=404
        )
        if stats:
            self.assert_is_dict(stats)


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityIssueLink(APISkillTest):
    """Tests for vulnerability-issue linking."""

    @pytest.mark.destructive
    def test_create_issue_from_vulnerability(
        self,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test creating an issue from a vulnerability."""
        vulnerabilities = self.api_get(
            gitlab_api,
            f"/projects/{gitlab_project_id}/vulnerabilities",
            expected_status=404
        )
        if not vulnerabilities:
            pytest.skip("No vulnerabilities available")

        vuln_id = vulnerabilities[0]["id"]

        try:
            # Create issue link
            issue = self.api_post(
                gitlab_api,
                f"/vulnerabilities/{vuln_id}/issue_links",
                {"target_project_id": gitlab_project_id}
            )
            self.assert_is_dict(issue)
        except GitLabAPIError:
            pytest.skip("Issue creation from vulnerability requires Ultimate")


@pytest.mark.live
@pytest.mark.p3
@pytest.mark.ultimate
class TestGitLabVulnerabilityPermissions(APISkillTest):
    """Permission tests for gitlab-vulnerability skill."""

    @pytest.mark.readonly
    def test_developer_can_list_vulnerabilities(
        self,
        developer_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test that developer can list vulnerabilities."""
        vulnerabilities = self.api_get(
            developer_api,
            f"/projects/{gitlab_project_id}/vulnerabilities",
            expected_status=404
        )
        # Should succeed or 404 if Ultimate not available
        if vulnerabilities:
            self.assert_is_list(vulnerabilities)

    @pytest.mark.destructive
    def test_reporter_cannot_change_vulnerability_state(
        self,
        reporter_api: GitLabAPI,
        gitlab_api: GitLabAPI,
        gitlab_project_id: int,
    ):
        """Test that reporter cannot change vulnerability state."""
        vulnerabilities = gitlab_api.get(
            f"/projects/{gitlab_project_id}/vulnerabilities"
        )
        if not vulnerabilities:
            pytest.skip("No vulnerabilities available")

        vuln_id = vulnerabilities[0]["id"]

        try:
            reporter_api.post(
                f"/vulnerabilities/{vuln_id}/dismiss",
                {}
            )
            pytest.fail("Expected 403 Forbidden")
        except GitLabAPIError as e:
            assert e.status_code in (403, 401, 404)
